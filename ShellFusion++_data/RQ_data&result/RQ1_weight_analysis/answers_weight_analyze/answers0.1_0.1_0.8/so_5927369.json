{
  "Query": "Recursively look for files with a specific extension",
  "Answers": [
    {
      "Command": "find",
      "MP Summary": "search for files in a directory hierarchy",
      "Most Similar TLDR Task": "Find files by extension",
      "Most Similar TLDR Script": "find {{root_path}} -name '{{*.ext}}'",
      "Top-3 Similar Questions": [
        "so_25693638: Recursively find files with a specific extension",
        "nl2bash_3759: Find all files/directories matching the regex pattern \".*\\\\.rb$\" under current directory",
        "so_4998290: How to find all file extensions recursively from a directory?"
      ],
      "Top-3 Scripts": [
        "so_25693638: find . -name '*.jpg' -o -name '*.png' -print | grep Robert",
        "nl2bash_3759: find . -regex \".*\\\\.rb$\"",
        "so_4998290: find . -type f -name '*.*' | sed 's|.*\\.||' | sort -u"
      ],
      "Explanations about Options": {
        "-regex": "File name matches regular expression pattern. This is a match on the whole path,\n not a search. For example, to match a file named `./fubar3', you can use the\n regular expression `.*bar.' or `.*b.*3', but not `f.*r3'. The regular expressions\n understood by find are by default Emacs Regular Expressions (except that `.'\n matches newline), but this can be changed with the -regextype option.",
        "-name": "This option is supported, but POSIX conformance depends on the POSIX conformance of\n the system's fnmatch(3) library function. As of findutils-4.2.2, shell\n metacharacters (`*', `?' or `[]' for example) will match a leading `.', because\n IEEE PASC interpretation 126 requires this. This is a change from previous\n versions of findutils.",
        "-print": "Quoting is handled in the same way as for -printf and -fprintf. If you are using\n find in a script or in a situation where the matched files might have arbitrary\n names, you should consider using -print0 instead of -print.",
        "-type": "File is of type c:"
      }
    },
    {
      "Command": "mv",
      "MP Summary": "move (rename) files",
      "Most Similar TLDR Task": "Move files in arbitrary locations",
      "Most Similar TLDR Script": "mv {{source}} {{target}}",
      "Top-3 Similar Questions": [
        "au_766644: Find a file beginning with a string but having a specific extension",
        "so_3837438: How do I remove a specific extension from files recursively using a bash script",
        "so_16701618: How to find files differing only by extension"
      ],
      "Top-3 Scripts": [
        "au_766644: find . -type f -name 'start*.ext' -exec mv -i {} foobar.txt \\;\n\nfind . -maxdepth 1 -type f -name 'start*.ext' -exec mv -i {} foobar.txt \\;",
        "so_3837438: find . -name '*.bx' -type f | while read NAME ; do mv \"${NAME}\" \"${NAME%.bx}\" ; done",
        "so_16701618: $ mv `ls *.sql|sed s/.sql$/.txt/g` dir\n\n$ ls\na.sql b.sql a.txt b.txt c.txt\n$ echo mv `ls *.sql|sed s/.sql/.txt/g` dir\nmv a.txt b.txt dir\n\n$ for f in *.sql; do mv \"$(echo $f|sed s/.sql$/txt/)\" dir; done\n\n$ for f in *.sql; do mv \"$f\" \"$(echo $f|sed s/.sql$/txt/)\" dir; done"
      ],
      "Explanations about Options": {
        "-i": "prompt before overwrite"
      }
    },
    {
      "Command": "file",
      "MP Summary": "determine file type",
      "Most Similar TLDR Task": "Look inside a zipped file and determine the file type(s) inside",
      "Most Similar TLDR Script": "file -z {{foo.zip}}",
      "Top-3 Similar Questions": [
        "so_38895490: bash finding files in directories recursively",
        "so_59253913: search recursive files with type of data that ended with specific extension in order to delete the files",
        "so_22161083: Script to look at files in a directory"
      ],
      "Top-3 Scripts": [
        "so_38895490: for file in `ls $1`",
        "so_59253913: find \"${path}\" \\\n    -type f \\\n    -name '*.pppd' \\\n    -exec bash -c 'test \"$(file \"${1}\"|awk -F: \"{print \\$NF}\")\" = \"data\"' -- {} \\; \\\n    -print",
        "so_22161083: trash=/home/user/Trash\nrestore=$HOME/restored/\nmkdir -p \"$restore\" 2>/dev/null\n\nfor files in \"$trash\"/*\ndo\n  read -p \"Do you want to keep $file (y/n): \" yn\n  [[ \"$yn\" == [yY] ]] && mv \"$file\" \"restore\"\ndone"
      ],
      "Explanations about Options": {}
    },
    {
      "Command": "mkdir",
      "MP Summary": "make directories",
      "Most Similar TLDR Task": "Create directories recursively (useful for creating nested dirs)",
      "Most Similar TLDR Script": "mkdir -p {{path/to/directory}}",
      "Top-3 Similar Questions": [
        "so_22161083: Script to look at files in a directory"
      ],
      "Top-3 Scripts": [
        "so_22161083: trash=/home/user/Trash\nrestore=$HOME/restored/\nmkdir -p \"$restore\" 2>/dev/null\n\nfor files in \"$trash\"/*\ndo\n  read -p \"Do you want to keep $file (y/n): \" yn\n  [[ \"$yn\" == [yY] ]] && mv \"$file\" \"restore\"\ndone"
      ],
      "Explanations about Options": {
        "-p": "no error if existing, make parent directories as needed"
      }
    },
    {
      "Command": "exec",
      "MP Summary": "execute commands and open, close, or copy file descriptors",
      "Most Similar TLDR Task": "Replace with the specified command using the current environment variables",
      "Most Similar TLDR Script": "exec {{command -with -flags}}",
      "Top-3 Similar Questions": [
        "au_757155: How to find a specific text in files with specific extension?"
      ],
      "Top-3 Scripts": [
        "au_757155: "
      ],
      "Explanations about Options": {}
    }
  ]
}