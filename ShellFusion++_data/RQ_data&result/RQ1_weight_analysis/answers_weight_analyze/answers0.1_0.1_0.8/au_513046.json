{
  "Query": "How to search strings inside files like in Windows without search monkey?",
  "Answers": [
    {
      "Command": "find",
      "MP Summary": "search for files in a directory hierarchy",
      "Most Similar TLDR Task": "Find files by matching multiple patterns",
      "Most Similar TLDR Script": "find {{root_path}} -name '{{*pattern_1*}}' -or -name '{{*pattern_2*}}'",
      "Top-3 Similar Questions": [
        "ul_609012: Searching multiple files for a string, without regular expressions?",
        "so_24683908: Find specific folders then search specific files inside them for a word",
        "ul_156232: Linux: Locating text file from a string input"
      ],
      "Top-3 Scripts": [
        "ul_609012: string='any /text\\ *string* without newline (\\n).'\nfind . -type f -exec grep -F -l -e \"$string\" {} +\n\nfind . -type f -exec grep -aFlze \"$string\" {} +",
        "so_24683908: for file in $(find ./k0* -name 'test.log'); do \n   grep -w 'ERROR' $file\n\ndone\n\nfor file in $(find ./k0* -name 'test.log'); do grep -w 'ERROR' $file; done",
        "ul_156232: find ~/Documents -name '*finances*'\n\nman find"
      ],
      "Explanations about Options": {
        "-name": "This option is supported, but POSIX conformance depends on the POSIX conformance of\n the system's fnmatch(3) library function. As of findutils-4.2.2, shell\n metacharacters (`*', `?' or `[]' for example) will match a leading `.', because\n IEEE PASC interpretation 126 requires this. This is a change from previous\n versions of findutils.",
        "-type": "File is of type c:"
      }
    },
    {
      "Command": "fgrep",
      "MP Summary": "print lines that match patterns",
      "Most Similar TLDR Task": "Search only lines that match entirely in files",
      "Most Similar TLDR Script": "fgrep -x {{path/to/file1}} {{path/to/file2}}",
      "Top-3 Similar Questions": [
        "so_18787830: Search multiple strings in multiple files",
        "so_13930501: How to search for a string in files with name containing a specific string in linux?"
      ],
      "Top-3 Scripts": [
        "so_18787830: fgrep -rlf messages.txt dir",
        "so_13930501: find . -type f -name '*20121218*' -exec fgrep -l \"MY:STRING\" {} \\;"
      ],
      "Explanations about Options": {
        "-l": "Suppress normal output; instead print the name of each input file from which output\n would normally have been printed. The scanning will stop on the first match.",
        "-r": "Read all files under each directory, recursively, following symbolic links only if\n they are on the command line. Note that if no file operand is given, grep searches\n the working directory. This is equivalent to the -d recurse option.",
        "-f": "Obtain patterns from FILE, one per line. If this option is used multiple times or\n is combined with the -e (--regexp) option, search for all patterns given. The\n empty file contains zero patterns, and therefore matches nothing."
      }
    },
    {
      "Command": "echo",
      "MP Summary": "display a line of text",
      "Most Similar TLDR Task": "Print a message without the trailing newline",
      "Most Similar TLDR Script": "echo -n \"{{Hello World}}\"",
      "Top-3 Similar Questions": [
        "ul_156232: Linux: Locating text file from a string input",
        "so_34153172: Finding all usages of a filename string in other files",
        "so_44780093: Searching Inside a Document for Multiple Strings with 'GREP'"
      ],
      "Top-3 Scripts": [
        "ul_156232: ",
        "so_34153172: cd /base/dir/to/check/presence/of/image/files\n\nwhile IFS= read -d '' -r f; do\n   img=\"${f##*/}\" # get the filename\n   grep -qFr \"$img\" --include=*.html --include=*.php --include=*.css . ||\n      echo \"$img not found\"\ndone < <(find /img-dir -type f -print0) > imgNotFound.txt",
        "so_44780093: if grep -q -f patterns \"$FILE\"; then\n    echo \"At least one match\"\nelse\n    echo \"No matches\"\nfi"
      ],
      "Explanations about Options": {}
    },
    {
      "Command": "sed",
      "MP Summary": "stream editor for filtering and transforming text",
      "Most Similar TLDR Task": "Replace separator / by any other character not used in the find or replace patterns, e.g., #",
      "Most Similar TLDR Script": "sed 's#{{find}}#{{replace}}#' {{filename}}",
      "Top-3 Similar Questions": [
        "so_19863094: Searching text string in file & replacing it",
        "so_37612886: Searching a string using grep in a range of multiple files",
        "ul_38340: Searching a file & excluding lines with a specified string"
      ],
      "Top-3 Scripts": [
        "so_19863094: #!/bin/bash\nif  eth=$(zenity --entry --text=\"Enter the access point\") &&\n    [[ $eth =~ ^eth[0-9]$ ]]\nthen\n     sed -i \"s/\\<eth[0-9]\\>/$eth/\" ~/conkyrc\nfi",
        "so_37612886: ls * | sed \"/2015-06-01/,/2016-06-03/p\" -n | xargs grep \"Live message\"\n\nsed \"/<BEGIN_REGEX>/,/<END_REGEX>/p\" -n",
        "ul_38340: sed '/repeat-info/d' file.log\nsed -n '/repeat-info/!p' file.log\n\nawk '!/repeat-info/' file.log"
      ],
      "Explanations about Options": {
        "-i": "edit files in place (makes backup if SUFFIX supplied)"
      }
    },
    {
      "Command": "which",
      "MP Summary": "locate a command",
      "Most Similar TLDR Task": "Search the PATH environment variable and display the location of any matching executables",
      "Most Similar TLDR Script": "which {{executable}}",
      "Top-3 Similar Questions": [
        "so_17231292: Searching for a string in multiple files on Linux"
      ],
      "Top-3 Scripts": [
        "so_17231292: grep [options] [searched string] [path]\n// -r is an option which states that it will use recursive search"
      ],
      "Explanations about Options": {}
    }
  ]
}