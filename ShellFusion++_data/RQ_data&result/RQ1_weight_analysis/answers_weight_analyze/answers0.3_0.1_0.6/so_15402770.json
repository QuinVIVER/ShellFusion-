{
  "Query": "How to grep and replace",
  "Answers": [
    {
      "Command": "tr",
      "MP Summary": "translate or delete characters",
      "Most Similar TLDR Task": "Replace all occurrences of a character from another command's output",
      "Most Similar TLDR Script": "echo {{text}} | tr {{find_character}} {{replace_character}}",
      "Top-3 Similar Questions": [
        "ul_90530: How to grep, then search and replace on the output?",
        "so_35801134: Replacing a delimiter"
      ],
      "Top-3 Scripts": [
        "ul_90530: iconv -l | grep ISO |head -5 |tr '/' '-'",
        "so_35801134: tr '\\001' '|'"
      ],
      "Explanations about Options": {}
    },
    {
      "Command": "sed",
      "MP Summary": "stream editor for filtering and transforming text",
      "Most Similar TLDR Task": "Replace separator / by any other character not used in the find or replace patterns, e.g., #",
      "Most Similar TLDR Script": "sed 's#{{find}}#{{replace}}#' {{filename}}",
      "Top-3 Similar Questions": [
        "ul_90530: How to grep, then search and replace on the output?",
        "ul_373420: search and replace using grep (not sed)",
        "so_39607425: grep a specific string and replace the file with sed"
      ],
      "Top-3 Scripts": [
        "ul_90530: iconv -l | grep ISO |head -5 | sed 's/\\//-/g'\n# or, to avoid needing to escape the backslashes:\niconv -l | grep ISO |head -5 | sed 's#/#-#g'",
        "ul_373420: sed 's/old/new/'",
        "so_39607425: sed -E -i.bak 's/(Free.*OK,[^.]*)[.][^,]*/\\1%/' file.txt\n\n$ sed -E -i.bak 's/(Free.*OK,[^.]*)[.][^,]*/\\1%/' file.txt\n$ cat file.txt\n23674, ICMP ping, OK, 1, 2016-08-25 17:11:02\n23686, Ping, OK, 1, 2016-08-25 16:05:04\n23689, SSH Service, OK, 1, 2016-08-25 16:05:49\n23693, System Free Space, OK, 97%, 2016-08-25 16:06:49\n23713, System Free Space, OK, 88%, 2016-09-20 18:02:22\n23745, C:\\ Free, OK, 63%, 2016-09-21 10:57:03"
      ],
      "Explanations about Options": {
        "-E": "use extended regular expressions in the script (for portability use POSIX -E)."
      }
    },
    {
      "Command": "echo",
      "MP Summary": "display a line of text",
      "Most Similar TLDR Task": "Print a message with environment variables",
      "Most Similar TLDR Script": "echo \"{{My path is $PATH}}\"",
      "Top-3 Similar Questions": [
        "ul_228824: Replace \"/\" with \"\\/\"",
        "ul_453855: Replace text with values",
        "so_21491877: Replace number of specified characters"
      ],
      "Top-3 Scripts": [
        "ul_228824: $ echo testdir=/tmp/testing | sed 's/\\//\\\\\\//g'\ntestdir=\\/tmp\\/testing\n\nvar=$(echo testdir=/tmp/testing | sed 's/\\//\\\\\\//g')",
        "ul_453855: ",
        "so_21491877: some_command() {\n    a=\"aaaaaaaaaaaaaaaaaaaaaaaaa\"\n    c=\"ccccccccccccccccccccccccc\"\n    echo \"${c:0:$1}${a:$1}\"\n}\n\n> some_command 3\ncccaaaaaaaaaaaaaaaaaaaaaa"
      ],
      "Explanations about Options": {}
    },
    {
      "Command": "grep",
      "MP Summary": "print lines that match patterns",
      "Most Similar TLDR Task": "Invert match for excluding specific strings",
      "Most Similar TLDR Script": "grep -v {{search_pattern}}",
      "Top-3 Similar Questions": [
        "ul_90530: How to grep, then search and replace on the output?",
        "ul_373420: search and replace using grep (not sed)",
        "ul_34679: Recursively replace string in files"
      ],
      "Top-3 Scripts": [
        "ul_90530: iconv -l | grep ISO |head -5 |tr '/' '-'\n\niconv -l | grep ISO |head -5 | sed 's/\\//-/g'\n# or, to avoid needing to escape the backslashes:\niconv -l | grep ISO |head -5 | sed 's#/#-#g'",
        "ul_373420: ",
        "ul_34679: find /your/path -type f -exec grep -l 'page_path\\\\' {} \\; -exec sed -i 's#page_path\\\\#page_path/#g' {} \\;"
      ],
      "Explanations about Options": {
        "-l": "Suppress normal output; instead print the name of each input file from which output\n would normally have been printed. The scanning will stop on the first match.",
        "-x": "Select only those matches that exactly match the whole line. For a regular\n expression pattern, this is like parenthesizing the pattern and then surrounding it\n with ^ and $."
      }
    },
    {
      "Command": "which",
      "MP Summary": "locate a command",
      "Most Similar TLDR Task": "If there are multiple executables which match, display all",
      "Most Similar TLDR Script": "which -a {{executable}}",
      "Top-3 Similar Questions": [
        "so_68388945: grep specific variable from output and replace value with another linux"
      ],
      "Top-3 Scripts": [
        "so_68388945: awk -v newValue=\"newVALUE\" '  ##Getting nfs4_getfacl output as input to awk program, creating newValue variable which has new value in it.\nBEGIN{ FS=OFS=\":\" }           ##Setting field separator and output field separator as : here.\n/:.:.*:/ && $3~/^[0-9]+$/{    ##Check if line contains :.:.*: format AND 3rd column is digits.\n  $3=newValue                 ##Then set newValue value to 3rd column here.\n}\n1                             ##printing edited/non-edited lines here.\n'"
      ],
      "Explanations about Options": {}
    }
  ]
}