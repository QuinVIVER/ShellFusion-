{
  "Query": "Find unique lines",
  "Answers": [
    {
      "Command": "uniq",
      "MP Summary": "report or omit repeated lines",
      "Most Similar TLDR Task": "Display only unique lines",
      "Most Similar TLDR Script": "sort {{file}} | uniq -u",
      "Top-3 Similar Questions": [
        "so_36595383: bash find unique lines in a file",
        "au_915570: How do I find a single unique line in a file?",
        "ul_249029: How to find unique word in a single line"
      ],
      "Top-3 Scripts": [
        "so_36595383: ",
        "au_915570: $ sort input.txt | uniq -u                                                                                               \nY\nZ\n\n$ uniq -u input.txt                                                                                                      \nY\nZ",
        "ul_249029: $ echo $var1 | tr ' ' '\\n' | sort | uniq\n50001\n50003\n\nvar2=\"$( echo $var1 | tr ' ' '\\n' | sort | uniq )\"\n\necho $var1 | tr ' ' '\\n' | sort | uniq  > ~/unique_results.txt"
      ],
      "Explanations about Options": {
        "-u": "only print unique lines"
      }
    },
    {
      "Command": "line",
      "MP Summary": "cache line size",
      "Most Similar TLDR Task": "Read input",
      "Most Similar TLDR Script": "line",
      "Top-3 Similar Questions": [
        "so_52163823: Find duplicate lines python",
        "so_47437429: Picking the lines sharing certain columns ( but not all )",
        "so_31854479: Bash find line number"
      ],
      "Top-3 Scripts": [
        "so_52163823: ",
        "so_47437429: ",
        "so_31854479: -n  # for printing line numbers\n-R  # for recursive grep\n-H  # for printing file names"
      ],
      "Explanations about Options": {}
    },
    {
      "Command": "sed",
      "MP Summary": "stream editor for filtering and transforming text",
      "Most Similar TLDR Task": "Replace only on lines matching the line pattern",
      "Most Similar TLDR Script": "sed '/{{line_pattern}}/s/{{find}}/{{replace}}/' {{filename}}",
      "Top-3 Similar Questions": [
        "so_58078722: regEx finding unique string",
        "so_14532485: find & sed: remove lines",
        "so_14747201: bash script find line and modify next line"
      ],
      "Top-3 Scripts": [
        "so_58078722: sed -i -E \"s/^@[[:xdigit:]]{8}(-[[:xdigit:]]{4}){3}-[[:xdigit:]]+([ \\t]+[^ \\t=]+=[^ \\t]+)*/& $BARCODETAG/\" file",
        "so_14532485: find . -name '*.php' -exec sed -i '/@category/d' {} \\;",
        "so_14747201: sed  '/.leaflet-right/{n;s/right/left/;}' < tester"
      ],
      "Explanations about Options": {
        "-E": "use extended regular expressions in the script (for portability use POSIX -E).",
        "-i": "edit files in place (makes backup if SUFFIX supplied)"
      }
    },
    {
      "Command": "find",
      "MP Summary": "search for files in a directory hierarchy",
      "Most Similar TLDR Task": "Find files by matching multiple patterns",
      "Most Similar TLDR Script": "find {{root_path}} -name '{{*pattern_1*}}' -or -name '{{*pattern_2*}}'",
      "Top-3 Similar Questions": [
        "su_1058859: Find only unique named files recursively",
        "ul_656128: Why locate gives more lines output than find",
        "so_14532485: find & sed: remove lines"
      ],
      "Top-3 Scripts": [
        "su_1058859: find . -type f -printf \"%f:%p\\n\" | awk -F: '!seen[$1]++ {print $2}'\n\nfind . -type f -printf \"%f\\0%p\\0\" |\n  awk -v RS='\\0' '{basename=$0; getline} !seen[basename]++'",
        "ul_656128: find / -name\n\nfind / -path",
        "so_14532485: find . -name '*.php' -exec sed -i '/@category/d' {} \\;"
      ],
      "Explanations about Options": {
        "-printf": "True; print format on the standard output, interpreting `\\' escapes and `%'\n directives. Field widths and precisions can be specified as with the `printf' C\n function. Please note that many of the fields are printed as %s rather than %d,\n and this may mean that flags don't work as you might expect. This also means that\n the `-' flag does work (it forces fields to be left-aligned). Unlike -print,\n -printf does not add a newline at the end of the string. The escapes and\n directives are:",
        "-type": "File is of type c:",
        "-name": "This option is supported, but POSIX conformance depends on the POSIX conformance of\n the system's fnmatch(3) library function. As of findutils-4.2.2, shell\n metacharacters (`*', `?' or `[]' for example) will match a leading `.', because\n IEEE PASC interpretation 126 requires this. This is a change from previous\n versions of findutils."
      }
    },
    {
      "Command": "awk",
      "MP Summary": "pattern scanning and processing language",
      "Most Similar TLDR Task": "Print the last column of each line in a file, using a comma (instead of space) as a field separator",
      "Most Similar TLDR Script": "awk -F ',' '{print $NF}' {{filename}}",
      "Top-3 Similar Questions": [
        "su_1058859: Find only unique named files recursively",
        "so_50818715: Finding the rows sharing information",
        "so_60432952: Finding a unique file"
      ],
      "Top-3 Scripts": [
        "su_1058859: find . -type f -printf \"%f:%p\\n\" | awk -F: '!seen[$1]++ {print $2}'\n\nfind . -type f -printf \"%f\\0%p\\0\" |\n  awk -v RS='\\0' '{basename=$0; getline} !seen[basename]++'",
        "so_50818715: awk 'FNR==NR{a[$1,$2,$3]++;next}  a[$1,$2,$3]>1' Input_file  Input_file",
        "so_60432952: $ awk 'NR==FNR{c[$1]++;next}; { if (c[$1] == 0) print $2; }' File1.txt  File2.txt\n*10.88.12/4.js\n*10.88.12/5.py"
      ],
      "Explanations about Options": {
        "-v": "FS=sepstring"
      }
    }
  ]
}