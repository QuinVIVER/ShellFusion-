{
  "Query": "grep exclude multiple strings",
  "Answers": [
    {
      "Command": "sed",
      "MP Summary": "stream editor for filtering and transforming text",
      "Most Similar TLDR Task": "Delete lines matching the line pattern",
      "Most Similar TLDR Script": "sed '/{{line_pattern}}/d' {{filename}}",
      "Top-3 Similar Questions": [
        "so_28647088: grep for a line in a file then remove the line",
        "so_51743995: grep to exclude pattern and exclude 2 preceding lines",
        "ul_205478: How to grep whitespace exclude new-line character?"
      ],
      "Top-3 Scripts": [
        "so_28647088: sed -i",
        "so_51743995: GNU sed\n\nsed -E 'N;N; /[acgt]{3}cc[acgt][acgt]{3}/d' ip.txt",
        "ul_205478: sed -n '/[\\t ]$/p' file \n    perl -ne 'print if /[\\t ]$/' file"
      ],
      "Explanations about Options": {
        "-E": "use extended regular expressions in the script (for portability use POSIX -E).",
        "-i": "edit files in place (makes backup if SUFFIX supplied)"
      }
    },
    {
      "Command": "line",
      "MP Summary": "cache line size",
      "Most Similar TLDR Task": "Read input",
      "Most Similar TLDR Script": "line",
      "Top-3 Similar Questions": [
        "so_52761146: bash to capture specific instance of pattern and exclude others",
        "so_9153170: Grep for a single line comment but exclude stuff like http://example.com"
      ],
      "Top-3 Scripts": [
        "so_52761146: while read -r line; do\n    [[ $line =~ del && ! $line =~ ins ]] && printf '%s\\n' \"$line\"\ndone < file",
        "so_9153170: $ echo $'http://www.example.com\\n   // single line comment' | grep \"^ *//.*\"\n   // single line comment"
      ],
      "Explanations about Options": {}
    },
    {
      "Command": "find",
      "MP Summary": "search for files in a directory hierarchy",
      "Most Similar TLDR Task": "Find files matching a given pattern, excluding specific paths",
      "Most Similar TLDR Script": "find {{root_path}} -name '{{*.py}}' -not -path '{{*/site-packages/*}}'",
      "Top-3 Similar Questions": [
        "so_47954092: Exclude wildcard containing string 'x'",
        "so_59407697: Exclude multiple folders (bash)",
        "so_46796378: Exclude certain string bash"
      ],
      "Top-3 Scripts": [
        "so_47954092: find . -type f -exec awk '/part1.*part2/ && !/part1.*string_x.*part2/' {} +",
        "so_59407697: find * -mindepth 0 -maxdepth 0 -not -name first_folder -not -name second_folder",
        "so_46796378: sudo find $FOCUS_HOME -maxdepth 1 -mtime +$userDays ! -name 'trunk' -printf '- %f\\n' -exec rm -rf {} \\"
      ],
      "Explanations about Options": {
        "-maxdepth": "Descend at most levels (a non-negative integer) levels of directories below the\n starting-points. -maxdepth 0 means only apply the tests and actions to the\n starting-points themselves.",
        "-name": "This option is supported, but POSIX conformance depends on the POSIX conformance of\n the system's fnmatch(3) library function. As of findutils-4.2.2, shell\n metacharacters (`*', `?' or `[]' for example) will match a leading `.', because\n IEEE PASC interpretation 126 requires this. This is a change from previous\n versions of findutils.",
        "-mindepth": "Do not apply any tests or actions at levels less than levels (a non-negative\n integer). -mindepth 1 means process all files except the starting-points.",
        "-type": "File is of type c:",
        "-mtime": "File's data was last modified n*24 hours ago. See the comments for -atime to\n understand how rounding affects the interpretation of file modification times.",
        "-not": "Same as ! expr, but not POSIX compliant.",
        "-printf": "True; print format on the standard output, interpreting `\\' escapes and `%'\n directives. Field widths and precisions can be specified as with the `printf' C\n function. Please note that many of the fields are printed as %s rather than %d,\n and this may mean that flags don't work as you might expect. This also means that\n the `-' flag does work (it forces fields to be left-aligned). Unlike -print,\n -printf does not add a newline at the end of the string. The escapes and\n directives are:"
      }
    },
    {
      "Command": "rm",
      "MP Summary": "remove files or directories",
      "Most Similar TLDR Task": "Recursively remove a directory and all its subdirectories",
      "Most Similar TLDR Script": "rm -r {{path/to/directory}}",
      "Top-3 Similar Questions": [
        "so_46796378: Exclude certain string bash"
      ],
      "Top-3 Scripts": [
        "so_46796378: sudo find $FOCUS_HOME -maxdepth 1 -mtime +$userDays ! -name 'trunk' -printf '- %f\\n' -exec rm -rf {} \\"
      ],
      "Explanations about Options": {
        "-r": "remove directories and their contents recursively",
        "-f": "ignore nonexistent files and arguments, never prompt"
      }
    },
    {
      "Command": "expr",
      "MP Summary": "evaluate arguments as an expression",
      "Most Similar TLDR Task": "Get position of the first character in 'string' that matches 'substring'",
      "Most Similar TLDR Script": "echo $(expr index {{string}} {{substring}})",
      "Top-3 Similar Questions": [
        "so_24190198: Process grep with pipe returns itself. How do I exclude it?"
      ],
      "Top-3 Scripts": [
        "so_24190198: grep -v expr"
      ],
      "Explanations about Options": {}
    }
  ]
}