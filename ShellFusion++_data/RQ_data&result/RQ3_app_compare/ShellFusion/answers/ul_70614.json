{
    "Answers": [
        {
            "Command": "ls",
            "Explanations about Options": {
                "-F(M)": "append indicator (one of */=>@|) to entries",
                "-a(C)": "Youâ€™re missing the extra hyphen: \"ls -a\" is the same as \"ls --all\", with two hyphens. .  \"ls -all\", with a single hyphen, is the same as \"ls -a -l -l\", which is the same as \"ls -a -l\", which is the same as \"ls -al\".",
                "-a(M)": "do not ignore entries starting with .",
                "-l(M)": "use a long listing format",
                "-r(M)": "reverse order while sorting",
                "-t(M)": "sort by modification time , newest first"
            },
            "MP Summary": "list directory contents",
            "Most Similar TLDR Script": "ls -F",
            "Most Similar TLDR Task": "List all files, with trailing `/` added to directory names",
            "Top-3 Scripts": [
                "ul_452339: ls -al\n\nls -al | awk '{$2=\"\"; print $0}'\n\nls -la | awk '{$2=$6=$7=$8=\"\"; print $0}'\n\nla() {\n    ls -la | awk '{$2=$6=$7=$8=\"\"; print $0}'\n}",
                "ul_117605: #!/bin/sh\n\nls -lrt >> lsOutput.log",
                "ul_549139: ls -a\n\nls --all\n\nls -all\n\nls -a -l -l"
            ],
            "Top-3 Similar Questions": [
                "ul_452339: Remove the number of hard links from the output of `ls -al` command",
                "ul_117605: LS Command output to file",
                "ul_549139: Difference between ls command options:`ls -a` `ls -al` `ls -all`"
            ]
        },
        {
            "Command": "sort",
            "Explanations about Options": {
                "-h(M)": "compare human readable numbers (e.g., 2K 1G)",
                "-k(M)": "sort via a key; KEYDEF gives location and type",
                "-l(C)": "You can of course use other commands to directly search for specific types (e.g. \"find . -maxdepth 1 -type d\") or use \"ls -l | sort\" to group similar types together based on this first character, but if you want to filter you should use \"grep\" to only select the appropriate lines from the output.",
                "-n(M)": "compare according to string numerical value",
                "-r(M)": "reverse the result of comparisons"
            },
            "MP Summary": "sort lines of text files",
            "Most Similar TLDR Script": "ls -lh | sort -h -k 5",
            "Most Similar TLDR Task": "Sort human-readable numbers (in this case the 5th field of `ls -lh`)",
            "Top-3 Scripts": [
                "so_23412774: ls -al | sort -k 6,6M -k 7,7n -r",
                "ul_165455: ls -l | sort",
                "so_48948643: c=0\nfind . -maxdepth 1 -type f -printf '%A@ %f\\n' |\nsort -n -k1 |\nwhile IFS= read -r line; do\n    echo mv \"${line#* }\" \"$(printf '%03d_%s\\n' $((++c)) \"${line#* }\")\"\ndone"
            ],
            "Top-3 Similar Questions": [
                "so_23412774: Linux sorting \"ls -al\" output by date",
                "ul_165455: How can I list files by type with ls?",
                "so_48948643: Prefix filename in for all the files in directory for ls (list command) output"
            ]
        },
        {
            "Command": "find",
            "Explanations about Options": {
                "-d(M)": "A synonym for -depth, for compatibility with FreeBSD, NetBSD, MacOS X and OpenBSD.",
                "-l(C)": "You can of course use other commands to directly search for specific types (e.g. \"find . -maxdepth 1 -type d\") or use \"ls -l | sort\" to group similar types together based on this first character, but if you want to filter you should use \"grep\" to only select the appropriate lines from the output.",
                "-maxdepth(M)": "Descend at most levels (a non-negative integer) levels of directories below the\n starting-points. -maxdepth 0 means only apply the tests and actions to the\n starting-points themselves.",
                "-n(M)": "for less than n ,",
                "-name(M)": "This option is supported, but POSIX conformance depends on the POSIX conformance of\n the system's fnmatch(3) library function. As of findutils-4.2.2, shell\n metacharacters (`*', `?' or `[]' for example) will match a leading `.', because\n IEEE PASC interpretation 126 requires this. This is a change from previous\n versions of findutils.",
                "-printf(M)": "True; print format on the standard output, interpreting `\\' escapes and `%'\n directives. Field widths and precisions can be specified as with the `printf' C\n function. Please note that many of the fields are printed as %s rather than %d,\n and this may mean that flags don't work as you might expect. This also means that\n the `-' flag does work (it forces fields to be left-aligned). Unlike -print,\n -printf does not add a newline at the end of the string. The escapes and\n directives are:",
                "-type(M)": "File is of type c:"
            },
            "MP Summary": "search for files in a directory hierarchy",
            "Most Similar TLDR Script": "find {{root_path}} -name '{{*.ext}}' -exec {{wc -l {} }}\\;",
            "Most Similar TLDR Task": "Run a command for each file (use `{}` within the command to access the filename)",
            "Top-3 Scripts": [
                "ul_328119: find -name 'templates' -type d -execdir ls {} \\;",
                "ul_165455: find . -maxdepth 1 -type d",
                "so_48948643: c=0\nfind . -maxdepth 1 -type f -printf '%A@ %f\\n' |\nsort -n -k1 |\nwhile IFS= read -r line; do\n    echo mv \"${line#* }\" \"$(printf '%03d_%s\\n' $((++c)) \"${line#* }\")\"\ndone"
            ],
            "Top-3 Similar Questions": [
                "ul_328119: List all files under different folders with same name",
                "ul_165455: How can I list files by type with ls?",
                "so_48948643: Prefix filename in for all the files in directory for ls (list command) output"
            ]
        },
        {
            "Command": "xargs",
            "Explanations about Options": {
                "-0(C)": "You could do \"xargs -0 stat --printf \"%Y %n\\0\"\" which would basically move your script forward, as \"ls\" isn't meant to be used for scripts.",
                "-0(M)": "Input items are terminated by a null character instead of by whitespace, and the\n quotes and backslash are not special (every character is taken literally).\n Disables the end of file string, which is treated like any other argument. Useful\n when input items might contain white space, quote marks, or backslashes. The GNU\n find -print0 option produces input suitable for this mode.",
                "-a(M)": "Read items from file instead of standard input. If you use this option, stdin\n remains unchanged when commands are run. Otherwise, stdin is redirected from\n /dev/null.",
                "-e(M)": "This option is a synonym for the -E option. Use -E instead, because it is POSIX\n compliant while this option is not. If eof-str is omitted, there is no end of file\n string. If neither -E nor -e is used, no end of file string is used.",
                "-n(C)": "The non-printable characters will be output as is. \"sed -n l\" will render CR characters as \"\\r\" and other non-printable characters using appropriate printable representations. To confirm which character it is, you can pipe that output to \"LC_ALL=C sed -n l\".",
                "-n(M)": "Use at most max-args arguments per command line. Fewer than max-args arguments\n will be used if the size (see the -s option) is exceeded, unless the -x option is\n given, in which case xargs will exit."
            },
            "MP Summary": "build and execute command lines from standard input",
            "Most Similar TLDR Script": "find . -name {{'*.backup'}} -print0 | xargs -0 rm -v",
            "Most Similar TLDR Task": "Delete all files with a `.backup` extension (`-print0` uses a null character to split file names, and `-0` uses it as delimiter)",
            "Top-3 Scripts": [
                "ul_484625: xargs touch < file.txt",
                "so_52772654: xargs -0 stat --printf \"%Y %n\\0\"\n\n<\"$tmp\" xargs -0 -i mv {} \"$outdir\"\n\n{ cat <\"$tmp\"; printf \"%s\\0\" \"$outdir\"; } | xargs -0 mv\n\n<\"$tmp\" xargs -0 sh -c 'outdir=\"$1\"; shift; mv \"$@\" \"$outdir\"' -- \"$outdir\""
            ],
            "Top-3 Similar Questions": [
                "ul_484625: ? at the end of files in while listing file using 'ls'",
                "so_52772654: Handle files with space in filename and output file names"
            ]
        },
        {
            "Command": "head",
            "Explanations about Options": {
                "-n(M)": "print the first NUM lines instead of the first 10; with the leading '-', print all\n but the last NUM lines of each file"
            },
            "MP Summary": "output the first part of files",
            "Most Similar TLDR Script": "head -n {{count_of_lines}} {{filename}}",
            "Most Similar TLDR Task": "Output the first few lines of a file",
            "Top-3 Scripts": [
                "so_4583801: OIFS=$IFS\nIFS=$'\\n'\n\nls -las -t $(cat list-of-files.txt) | head -10\nIFS=$OIFS"
            ],
            "Top-3 Similar Questions": [
                "so_4583801: Listing files in date order with spaces in filenames"
            ]
        }
    ],
    "Query": "How to output only file names (with spaces) in ls -Al?"
}