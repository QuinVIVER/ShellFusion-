{
    "Answers": [
        {
            "Command": "find",
            "Explanations about Options": {
                "-name(M)": "This option is supported, but POSIX conformance depends on the POSIX conformance of\n the system's fnmatch(3) library function. As of findutils-4.2.2, shell\n metacharacters (`*', `?' or `[]' for example) will match a leading `.', because\n IEEE PASC interpretation 126 requires this. This is a change from previous\n versions of findutils.",
                "-type(M)": "File is of type c:"
            },
            "MP Summary": "search for files in a directory hierarchy",
            "Most Similar TLDR Script": "find {{root_path}} -path '{{**/lib/**/*.ext}}'",
            "Most Similar TLDR Task": "Find files matching a path pattern",
            "Top-3 Scripts": [
                "so_33455069: find ... -exec ... {} \\;\n\nfind ... -print0 | xargs -0 -n 1 ...\n\nfind ... -exec ... {} +\n\nfind ... -print0 | xargs -0 ...\n\nfind /myprojects -type f -name '*.cpp' -print0 | \n  xargs -0 echo sed -i 's/previousword/newword/g'\n\nfind /myprojects -type f -name '*.cpp' -print0 | \n   xargs -0 -n 1 sed -i 's/previousword/newword/g'\n\nfind /myprojects -type f -name '*.cpp' -exec sed -i 's/previousword/newword/g' '{}' +",
                "ul_34679: find /your/path -type f -exec grep -l 'page_path\\\\' {} \\; -exec sed -i 's#page_path\\\\#page_path/#g' {} \\;",
                "so_51450330: find . -name 'dev.rc' -type f -exec sed -i '' 's/bar/baz/g' {} +"
            ],
            "Top-3 Similar Questions": [
                "so_33455069: Awk/Sed: How to do a recursive find/replace of a string in files with a certain file extension?",
                "ul_34679: Recursively replace string in files",
                "so_51450330: Replace string in multiple files recursively"
            ]
        },
        {
            "Command": "grep",
            "Explanations about Options": {
                "--null(C)": "Edit: As suggested in comment, use \"grep --null | xargs -0\".",
                "--null(M)": "Output a zero byte (the ASCII NUL character) instead of the character that normally\n follows a file name. For example, grep -lZ outputs a zero byte after each file\n name instead of the usual newline. This option makes the output unambiguous, even\n in the presence of file names containing unusual characters like newlines. This\n option can be used with commands like find -print0, perl -0, sort -z, and xargs -0\n to process arbitrary file names, even those that contain newline characters.",
                "-F(M)": "Interpret PATTERNS as fixed strings, not regular expressions.",
                "-l(M)": "Suppress normal output; instead print the name of each input file from which output\n would normally have been printed. The scanning will stop on the first match.",
                "-r(M)": "Read all files under each directory, recursively, following symbolic links only if\n they are on the command line. Note that if no file operand is given, grep searches\n the working directory. This is equivalent to the -d recurse option.",
                "-x(M)": "Select only those matches that exactly match the whole line. For a regular\n expression pattern, this is like parenthesizing the pattern and then surrounding it\n with ^ and $."
            },
            "MP Summary": "print lines that match patterns",
            "Most Similar TLDR Script": "grep -F {{exact_string}} {{path/to/file}}",
            "Most Similar TLDR Task": "Search for an exact string",
            "Top-3 Scripts": [
                "so_15920276: grep -rl $oldstring /path/to/folder | xargs sed -i s@$oldstring@$newstring@g",
                "ul_34679: find /your/path -type f -exec grep -l 'page_path\\\\' {} \\; -exec sed -i 's#page_path\\\\#page_path/#g' {} \\;",
                "ul_113746: grep -rl --null term1 . | xargs -0 sed -e 's/term1/term2/' | less\n\ngrep -rl --null term1 . | xargs -0 sed -i.bak -e 's/term1/term2/'\ndiff somefile.bak somefile\n# verify changes were correct\n\ngrep --null | xargs -0"
            ],
            "Top-3 Similar Questions": [
                "so_15920276: Find and Replace string in all files recursive using grep and sed",
                "ul_34679: Recursively replace string in files",
                "ul_113746: Test recursive sed search and replace before running"
            ]
        },
        {
            "Command": "sed",
            "Explanations about Options": {
                "-i(M)": "edit files in place (makes backup if SUFFIX supplied)"
            },
            "MP Summary": "stream editor for filtering and transforming text",
            "Most Similar TLDR Script": "sed 's#{{find}}#{{replace}}#' {{filename}}",
            "Most Similar TLDR Task": "Replace separator / by any other character not used in the find or replace patterns, e.g., #",
            "Top-3 Scripts": [
                "so_33455069: sed -i 's/previousword/newword/g' /myprojects/file1.cpp /myprojects/file2.cpp ...\n\nfind /myprojects -type f -name '*.cpp' -print0 | \n  xargs -0 echo sed -i 's/previousword/newword/g'\n\nfind /myprojects -type f -name '*.cpp' -print0 | \n   xargs -0 -n 1 sed -i 's/previousword/newword/g'\n\nfind /myprojects -type f -name '*.cpp' -exec sed -i 's/previousword/newword/g' '{}' +",
                "so_15920276: grep -rl $oldstring /path/to/folder | xargs sed -i s@$oldstring@$newstring@g",
                "ul_34679: find /your/path -type f -exec grep -l 'page_path\\\\' {} \\; -exec sed -i 's#page_path\\\\#page_path/#g' {} \\;"
            ],
            "Top-3 Similar Questions": [
                "so_33455069: Awk/Sed: How to do a recursive find/replace of a string in files with a certain file extension?",
                "so_15920276: Find and Replace string in all files recursive using grep and sed",
                "ul_34679: Recursively replace string in files"
            ]
        },
        {
            "Command": "cut",
            "Explanations about Options": {},
            "MP Summary": "remove sections from each line of files",
            "Most Similar TLDR Script": "cut -d'{{ }}' -f{{3-}}",
            "Most Similar TLDR Task": "Cut out the fields 3 through to the end of each line, using a space as a delimiter",
            "Top-3 Scripts": [
                "so_40508542: $(cut -d: -f1 $FILENAME)"
            ],
            "Top-3 Similar Questions": [
                "so_40508542: Find and Replace with awk"
            ]
        },
        {
            "Command": "tr",
            "Explanations about Options": {
                "-d(M)": "delete characters in SET1, do not translate"
            },
            "MP Summary": "translate or delete characters",
            "Most Similar TLDR Script": "tr {{find_character}} {{replace_character}} < {{filename}}",
            "Most Similar TLDR Task": "Replace all occurrences of a character in a file, and print the result",
            "Top-3 Scripts": [
                "au_540532: sed \"s/this is test/$(sed -e 's/[\\&/]/\\\\&/g' -e 's/$/\\\\n/' bar | tr -d '\\n')/\" foo"
            ],
            "Top-3 Similar Questions": [
                "au_540532: Replacing a string by a file using Sed"
            ]
        }
    ],
    "Query": "How to do a recursive find/replace of a string with awk or sed?"
}