{
  "Query": "How do I become a \"superuser\"?",
  "Answers": [
    {
      "Command": "and",
      "MP Summary": "auto nice daemon",
      "Top-3 Similar Questions": [
        "so_20123072: Change file permission without being a superuser"
      ],
      "Top-3 Scripts": [
        "so_20123072: "
      ],
      "Explanations about Options": {}
    },
    {
      "Command": "reboot",
      "MP Summary": "Halt, power-off or reboot the machine",
      "Top-3 Similar Questions": [
        "au_1197866: What Causes a File System to become Broken?"
      ],
      "Top-3 Scripts": [
        "au_1197866: "
      ],
      "Explanations about Options": {}
    },
    {
      "Command": "as",
      "MP Summary": "or  any situation  where  you want to make sure you're doing a clean install of your dependencies. It  can  be  significantly  faster  than  a  regular  npm  install  by  skipping   certain user-oriented  features.  It  is  also  more strict than a regular install, which can help catch errors or inconsistencies caused by the incrementally-installed  local  environments of most npm users. In short, the main differences between using npm install and npm ci are: \u00b7 The project must have an existing package-lock.json or npm-shrinkwrap.json. \u00b7 If dependencies in the package lock do not match those in package.json, npm ci will exit with an error, instead of updating the package lock. \u00b7 npm ci can only install entire projects at a time:  individual  dependencies  cannot  be added with this command. \u00b7 If  a  node_modules  is  already present, it will be automatically removed before npm ci begins its install. \u00b7 It will  never  write  to  package.json  or  any  of  the  package-locks:  installs  are essentially frozen. See Also \u00b7 npm help install \u00b7 npm help package-locks April 2020                                  NPM-CI(1)",
      "Top-3 Similar Questions": [
        "ul_28454: How do I force the user to become root",
        "so_20123072: Change file permission without being a superuser"
      ],
      "Top-3 Scripts": [
        "ul_28454: # Check if we're root and re-execute if we're not.\nrootcheck () {\n    if [ $(id -u) != \"0\" ]\n    then\n        sudo \"$0\" \"$@\"  # Modified as suggested below.\n        exit $?\n    fi\n}",
        "so_20123072: "
      ],
      "Explanations about Options": {}
    },
    {
      "Command": "then",
      "MP Summary": "presumably creating or updating package.json and running any other initialization-related operations. The init command is transformed to a corresponding npx operation as follows: \u00b7 npm init foo -> npx create-foo \u00b7 npm init @usr/foo -> npx @usr/create-foo \u00b7 npm init @usr -> npx @usr/create Any  additional  options  will  be passed directly to the command, so npm init foo --hello will map to npx create-foo --hello. If the initializer is omitted (by just calling npm init), init will fall  back  to  legacy init  behavior.  It  will  ask you a bunch of questions, and then write a package.json for you. It will attempt to make reasonable guesses based on  existing  fields,  dependencies, and  options selected. It is strictly additive, so it will keep any fields and values that were already set. You can also use -y/--yes to skip the questionnaire altogether.  If  you pass --scope, it will create a scoped package. See Also \u00b7 https://github.com/isaacs/init-package-json \u00b7 npm help package.json \u00b7 npm help version \u00b7 npm help scope April 2020                                NPM-INIT(1)",
      "Top-3 Similar Questions": [
        "ul_28454: How do I force the user to become root",
        "ul_646143: Wrong keyboard layout even though everything in the OS seem to report correct/wanted layout - e.g. \u00e5\u00e4\u00f6 becomes [';"
      ],
      "Top-3 Scripts": [
        "ul_28454: # Check if we're root and re-execute if we're not.\nrootcheck () {\n    if [ $(id -u) != \"0\" ]\n    then\n        sudo \"$0\" \"$@\"  # Modified as suggested below.\n        exit $?\n    fi\n}",
        "ul_646143: userxkbmap=\"$HOME/.Xkbmap\"\n...\n# merge in keymaps\nif [ -f \"$userxkbmap\" ]; then\n    setxkbmap `cat \"$userxkbmap\"`\n    XKB_IN_USE=yes\nfi\n\n# Load keymaps\nfor file in \"/etc/X11/Xkbmap\" \"$HOME/.Xkbmap\"; do\n    if [ -f \"$file\" ]; then\n        echo \"Loading keymap: $file\"\n        setxkbmap `cat \"$file\"`\n        XKB_IN_USE=yes\n    fi\ndone"
      ],
      "Explanations about Options": {}
    },
    {
      "Command": "bin",
      "MP Summary": "presumably creating or updating package.json and running any other initialization-related operations. The init command is transformed to a corresponding npx operation as follows: \u00b7 npm init foo -> npx create-foo \u00b7 npm init @usr/foo -> npx @usr/create-foo \u00b7 npm init @usr -> npx @usr/create Any  additional  options  will  be passed directly to the command, so npm init foo --hello will map to npx create-foo --hello. If the initializer is omitted (by just calling npm init), init will fall  back  to  legacy init  behavior.  It  will  ask you a bunch of questions, and then write a package.json for you. It will attempt to make reasonable guesses based on  existing  fields,  dependencies, and  options selected. It is strictly additive, so it will keep any fields and values that were already set. You can also use -y/--yes to skip the questionnaire altogether.  If  you pass --scope, it will create a scoped package. See Also \u00b7 https://github.com/isaacs/init-package-json \u00b7 npm help package.json \u00b7 npm help version \u00b7 npm help scope April 2020                                NPM-INIT(1)",
      "Top-3 Similar Questions": [
        "so_18873788: How to make a python script become a unix command?",
        "ul_242178: Why in booting prompt characters become suddenly bold?"
      ],
      "Top-3 Scripts": [
        "so_18873788: mv foobar /usr/local/bin",
        "ul_242178: #!/bin/bash\n    /bin/setupcon"
      ],
      "Explanations about Options": {}
    }
  ]
}