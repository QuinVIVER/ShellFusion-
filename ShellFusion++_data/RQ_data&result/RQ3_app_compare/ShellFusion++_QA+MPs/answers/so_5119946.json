{
  "Query": "find -exec with multiple commands",
  "Answers": [
    {
      "Command": "yash",
      "MP Summary": "a POSIX-compliant command line shell",
      "Top-3 Similar Questions": [
        "ul_84265: linux shell: find -exec in find -exec"
      ],
      "Top-3 Scripts": [
        "ul_84265: "
      ],
      "Explanations about Options": {}
    },
    {
      "Command": "args",
      "MP Summary": "manipulate and output command arguments.",
      "Top-3 Similar Questions": [
        "ul_371932: find command with multiple pattern not returning any output"
      ],
      "Top-3 Scripts": [
        "ul_371932: args=()  \nargs+=( -name \"*.ab\" )\nargs+=( -or -name \"*.bc\" ) \n\nfind ... \\( \"${args[@]}\" \\)"
      ],
      "Explanations about Options": {}
    },
    {
      "Command": "xargs",
      "MP Summary": "build and execute command lines from standard input",
      "Top-3 Similar Questions": [
        "ul_212957: find: multiple `-exec`s with conditions",
        "ul_296875: How do I find files with multiple empty lines?",
        "ul_84265: linux shell: find -exec in find -exec"
      ],
      "Top-3 Scripts": [
        "ul_212957: find . -type f -exec grep -lFZ <i>SOME_STRING</i> {} + | xargs -0 gsed -s -i '<i>COMMAND</i>'\n\ngfind /tmp/ -type f \\( -name \"*.h\" -o -name \"*.cpp\" \\) \\\n-exec ggrep -lFZ LARGE_INTEGER {} + | \\\nxargs -0 gsed -s -i '1s/^/#include <stdint.h>\\n/'",
        "ul_296875: # easy to type version\ngit find | xargs pcregrep -l -M $'\\n\\n\\n' >/tmp/x\n# more secure version\ngit find -print0 | xargs -0r pcregrep -l -M $'\\n\\n\\n' >/tmp/x\n\n# easy to type version\n$EDITOR $(git find \\*.java | xargs pcregrep -l -M $'\\n\\n\\n')\n# somewhat more secure version\ngit find -print0 | xargs -0r pcregrep -l -M $'\\n\\n\\n' | xargs $EDITOR --",
        "ul_84265: xargs -r0a <(\n    find ~/.config/google-chrome -type d -name test -print0\n  ) sh -c 'exec find \"$@\" -exec chmod 555 {} +' sh"
      ],
      "Explanations about Options": {
        "-0": "Input items are terminated by a null character instead of by whitespace, and the\n quotes and backslash are not special (every character is taken literally).\n Disables the end of file string, which is treated like any other argument. Useful\n when input items might contain white space, quote marks, or backslashes. The GNU\n find -print0 option produces input suitable for this mode.",
        "-i": "This option is a synonym for -Ireplace-str if replace-str is specified. If the\n replace-str argument is missing, the effect is the same as -I{}. This option is\n deprecated; use -I instead."
      }
    },
    {
      "Command": "sudo",
      "MP Summary": "execute a command as another user",
      "Top-3 Similar Questions": [
        "so_67701729: GNU find, keep {} as is with -exec"
      ],
      "Top-3 Scripts": [
        "so_67701729: sudo find /path/to/file -type f ! -newermt '06:00:00' \\\n        -exec echo -e \"\\\\0173\\\\0175\" > '/path/to/file' \\;"
      ],
      "Explanations about Options": {}
    },
    {
      "Command": "sql",
      "MP Summary": "execute a command on a database determined by a dburl",
      "Top-3 Similar Questions": [
        "so_60342823: What is the ansible equivalent to find -exec cp with file extensions filtered?"
      ],
      "Top-3 Scripts": [
        "so_60342823: - debug: var=path_file\n\n    - name: test sql copy\n      copy:\n#       src: \"{{ test_fact.path}}\"\n        src: \"{{ item }}\"\n        dest: \"/home/me/test/test_copy/sql\"\n        owner: me\n        mode: 0755\n      loop: \"{{ path_file }}\""
      ],
      "Explanations about Options": {}
    }
  ]
}