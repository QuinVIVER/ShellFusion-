{
  "Query": "How do I limit the number of files printed by ls?",
  "Answers": [
    {
      "Command": "echo",
      "Top-3 Similar Questions": [
        "so_57086992: How to limit number of iterations in a for loop in shell script",
        "su_387673: How can I limit the number of directories in my prompt?",
        "ul_22992: How to limit the number of lines a command's output has available in bash?"
      ],
      "Top-3 Scripts": [
        "so_57086992: #!/usr/bin/env bash\n#              ^^^^- NOT /bin/sh; arrays require a shell with ksh extensions.\n\nIDs=a1,b2,c3,d4,e5,f6,g7,h8,i9,j10,k11,l12,m13,n14  # original input\nIFS=, read -r -a id_arr <<<\"$IDs\"                   # transform into an array\nmax_count=10                                        # input w/ count to process\n\nfor i in \"${id_arr[@]:0:max_count}\"; do             # iterate only over that many\n  echo \"Fetching results for $i by running sql against DB\"\ndone",
        "su_387673: # shorten a path in $1 to max of $2 characters, prepending a \"...\"\nfunction __shortpath {\n    if [[ ${#1} -gt $2 ]]; then\n        len=$2+3\n        echo \"...\"${1: -$len}\n    else\n        echo $1\n    fi\n}\nPS1='\\[\\033[01;32m\\][$(__shortpath \"\\w\" 50)\\[\\033[00m\\]\\[\\033[01;34m\\]$(__git_ps1 \" (%s)\")\\033[01;32m\\]]\\[\\033[00m\\]\\$ '",
        "ul_22992: nohup wget http://cdimage.debian.org/debian-cd/6.0.3/amd64/iso-dvd/debian-6.0.3-amd64-DVD-1.iso &\nel=\"$(tput el)\"; # Clear to the end of the line\ntail -n 1 -f nohup.out | while read -r line; do echo -n $'\\r'\"$el$line\"; done;"
      ]
    },
    {
      "Command": "to",
      "Top-3 Similar Questions": [
        "ul_558014: Limit number of matches of find command",
        "so_5013151: How do I limit the number of results returned from grep?",
        "so_24842214: How to limit the number of feed status returned by the Facebook PowerShell Module"
      ],
      "Top-3 Scripts": [
        "ul_558014: mv ./**/*(-.D[1,1000]) /path/to/collection1    # move first 1000 files\nmv ./**/*(-.D[1,1000]) /path/to/collection2    # move next 1000 files\n\npathnames=( ./**/*(-.D) )\n\nmv $pathnames[1,1000]    /path/to/collection1\nmv $pathnames[1001,2000] /path/to/collection2\n\nshopt -s globstar dotglob nullglob\n\npathnames=()\nfor pathname in ./**/*; do\n    [[ -f $pathname ]] && pathnames+=( \"$pathname\" )\ndone\n\nmv \"${pathnames[@]:0:1000}\"    /path/to/collection1\nmv \"${pathnames[@]:1000:1000}\" /path/to/collection2\nmv \"${pathnames[@]:2000:1000}\" /path/to/collection3",
        "so_5013151: -m NUM, --max-count=NUM\n        Stop reading a file after NUM matching lines.  If the  input  is\n        standard  input  from a regular file, and NUM matching lines are\n        output, grep ensures that the standard input  is  positioned  to\n        just  after the last matching line before exiting, regardless of\n        the presence of trailing context lines.  This enables a  calling\n        process  to resume a search.",
        "so_24842214: Get-FBFeed |\nSort-Object -Descending Date |#You need to change Date to the right property, and maybe cast the value to datetime\nSelect-Object -First 10"
      ]
    },
    {
      "Command": "then",
      "Top-3 Similar Questions": [
        "so_18114010: Limit the number of concurrent processes spawned by incrond",
        "su_387673: How can I limit the number of directories in my prompt?",
        "so_11994282: way to limit the number of executions per unit time of Linux command"
      ],
      "Top-3 Scripts": [
        "so_18114010: processName=myprocess\n\n    if [ $(ps -ef |grep -v grep|grep ${processName} |wc -l) -le 4 ]\n    then\n      do something\n    fi",
        "su_387673: # shorten a path in $1 to max of $2 characters, prepending a \"...\"\nfunction __shortpath {\n    if [[ ${#1} -gt $2 ]]; then\n        len=$2+3\n        echo \"...\"${1: -$len}\n    else\n        echo $1\n    fi\n}\nPS1='\\[\\033[01;32m\\][$(__shortpath \"\\w\" 50)\\[\\033[00m\\]\\[\\033[01;34m\\]$(__git_ps1 \" (%s)\")\\033[01;32m\\]]\\[\\033[00m\\]\\$ '",
        "ul_337635: #!/bin/sh\nfor instance in /var/lib/myapp/instances/*; do\n  flock -w 0 -E 128 \"$instance\" myapp.original \"$@\"\n  ret=$?\n  if [ \"$ret\" -ne 128 ]; then exit \"$ret\"; fi\ndone\necho >&2 \"Maximum number of instances of myapp reached.\"\nexit 128"
      ]
    },
    {
      "Command": "find",
      "Top-3 Similar Questions": [
        "ul_558014: Limit number of matches of find command",
        "so_47922994: limit number of results of find, head is not working",
        "so_62381718: How to limit the number of results from find?"
      ],
      "Top-3 Scripts": [
        "so_47922994: find / -type f | head -n5 | tr '\\n' '\\0' | xargs -0 ls\n\nfind -L $line | head -n50 | tr '\\n' '\\0' | xargs -0 ls > $a$(basename $line)",
        "so_62381718: find -name '*.jpg' -print0 \\\n| head -z -n 50 \\\n| xargs -0 cp -t /destination",
        "su_112144: find /some/log/dir -type f -name \"*.log\" | xargs rm"
      ]
    },
    {
      "Command": "line",
      "Top-3 Similar Questions": [
        "so_5013151: How do I limit the number of results returned from grep?",
        "so_47922994: limit number of results of find, head is not working",
        "ul_22992: How to limit the number of lines a command's output has available in bash?"
      ],
      "Top-3 Scripts": [
        "so_5013151: -m NUM, --max-count=NUM\n        Stop reading a file after NUM matching lines.  If the  input  is\n        standard  input  from a regular file, and NUM matching lines are\n        output, grep ensures that the standard input  is  positioned  to\n        just  after the last matching line before exiting, regardless of\n        the presence of trailing context lines.  This enables a  calling\n        process  to resume a search.",
        "so_47922994: find -L $line | head -n50 | tr '\\n' '\\0' | xargs -0 ls > $a$(basename $line)",
        "ul_22992: nohup wget http://cdimage.debian.org/debian-cd/6.0.3/amd64/iso-dvd/debian-6.0.3-amd64-DVD-1.iso &\nel=\"$(tput el)\"; # Clear to the end of the line\ntail -n 1 -f nohup.out | while read -r line; do echo -n $'\\r'\"$el$line\"; done;"
      ]
    }
  ]
}